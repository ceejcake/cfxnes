/* global window, Buffer */

/**
 * Detects endianness.
 *
 * @returns {string} 'LE' (little-endian) or 'BE' (big-endian)
 */
export function detectEndianness() {
  const u16 = new Uint16Array([0x1234]);
  const u8 = new Uint8Array(u16.buffer);
  return u8[0] === 0x34 ? 'LE' : 'BE';
}

/**
 * Decodes a base-64 encoded string.
 *
 * @param {string} input - encoded string
 * @returns {string} decoded string
 */
export function decodeBase64(input) {
  if (typeof window !== 'undefined' && typeof window.atob === 'function') {
    return window.atob(input);
  }
  if (typeof Buffer === 'function') {
    return Buffer.from(input, 'base64').toString('binary');
  }
  throw new Error('Unable to decode base64 string');
}

/**
 * Formats a number as size in B, KB or MB.
 *
 * @param {number=} size - size value
 * @return {string|undefined} formatted size or undefined if the size is not a number
 */
export function formatSize(size) {
  if (typeof size !== 'number') {
    return undefined;
  }
  if (Math.abs(size) < 1024) {
    return size + ' B';
  }
  if (Math.abs(size) < 1024 * 1024) {
    return roundDecimalPlaces(size / 1024) + ' KB';
  }
  return roundDecimalPlaces(size / (1024 * 1024)) + ' MB';
}

/**
 * Rounds a number to have at most 3 decimal places.
 *
 * @param {number} number - number
 * @returns {number} rounded number
 */
function roundDecimalPlaces(number) {
  return (~~(1000 * number)) / 1000;
}

// Max length of string generated by the describe function
const DESCRIPTION_MAX_STRING_LENGTH = 80;

/**
 * Converts a value to its string representation.
 *
 * Unlike toString method:
 * - It generates more descriptive output.
 * - It limits length of the generated output.
 *
 * @param {*} value - value to describe
 * @return {string} - value description
 */
export function describe(value) {
  const type = typeof value;
  if (type === 'string') {
    if (value.length > DESCRIPTION_MAX_STRING_LENGTH) {
      return `"${value.substr(0, DESCRIPTION_MAX_STRING_LENGTH)}..."`;
    }
    return `"${value}"`;
  }
  if (type === 'function') {
    const constructorName = getFunctionName(value.constructor);
    const name = getFunctionName(/** @type {function(...*):*} */ (value));
    return name ? `${constructorName}(${name})` : constructorName;
  }
  if (value && type === 'object') {
    const constructorName = getFunctionName(value.constructor);
    if (constructorName === 'Object') {
      return constructorName;
    }
    const {length} = value;
    return length != null ? `${constructorName}(${length})` : constructorName;
  }
  return String(value);
}

// Regexp to extract function name from its source code
const functionNameRegexp = /function ([^(]+)/;

/**
 * Returns name of a function.
 *
 * @param {function(...*):*} fn - function
 * @returns {string} function name
 */
function getFunctionName(fn) {
  if (fn.name) {
    return fn.name;
  }
  // IE does not support the 'name' property
  const matchResult = fn.toString().match(functionNameRegexp);
  if (matchResult && matchResult[1]) {
    return matchResult[1];
  }
  return '';
}
